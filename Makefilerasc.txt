all:
	gcc so_long.c so_long_utils.c    -o so_long
	@echo -e "\n"
	./so_long map/map1.txt | cat -e
	@echo -e "\n"

al:
	gcc r.c -o r
	./r

a:
	gcc so_long.c so_long.h so_long_utils.c ./Libft/libft.a -L./minilibx-linux -lmlx -lXext -lX11 -lm -o so_long
        
m:
	gcc main.c ./Libft/libft.a -L./minilibx-linux -lmlx -lXext -lX11 -lm -o so_long
	./so_long map1.bar
	./so_long map2.bar

mm:
	gcc main.c ./Libft/libft.a -L./minilibx-linux -lmlx -lXext -lX11 -lm -o so_long
	./so_long map1.bar
	./so_long map2.bar

n:
	norminette ./*.c ./*.h

pull:
	@git pull
	make -C libft/
	all
	make fclean -C libft/

push:
	git add .; git commit -m "caso resolvido" ;git push

to_fill:
	gcc flood_fill.c -o flood_fill && ./flood_fill

so_long:
	gcc so_long.c ./libft/libft.a -L./minilibx_linux -l mlx -lXext -lX11 -lm -o so_long

$(OBJS): %.o: %.c
	@gcc $(FLAGS) -c $< -o $@

$(BOBJS): %.o: %.c
	@gcc $(FLAGS) -c $< -o $@

$(NAME): $(OBJS)
	@ar rc $(NAME) $(OBJS)
	@make clean

bonus: $(OBJS) $(BOBJS)
	@ar rc $(NAME) $(OBJS) $(BOBJS)
	@make clean



	// mlx_destroy_image(window->mlx, window->bg);
	// mlx_destroy_window(window->mlx, window->win);
	// mlx_destroy_display(window->mlx);
	// free(window->mlx);
    // exit(0);

t_point	*find_in_all_matrix(char **matrix, char ch)
{
	int		l;
	int		c;
	int		i;
	int		len;
	t_point	*list_point;

	l = 0;
	i = 0;
	len = count_occurrence(matrix, ch);
	list_point = (t_point *)ft_calloc(len + 1, sizeof(t_point));
	if (!list_point)
		return (NULL);
	while (matrix[l])
	{
		c = 0;
		while (matrix[l][c])
		{
			if (matrix[l][c] == ch)
			{
				list_point[i] = (t_point){c, l};
				i++;
			}
			c++;
		}
		l++;
	}
	list_point[i] = (t_point){-1, -1};
	return (list_point);
}

50x53

///////////////////////////////
t_point	*find_in_all_matrix(char **matrix, char ch)
{
	int		l;
	int		i;
	int		len;
	t_point	*list_point;

	l = 0;
	i = 0;
	len = count_occurrence(matrix, ch);
	list_point = (t_point *)ft_calloc(len + 1, sizeof(t_point));
	if (!list_point)
		return (NULL);
	while (matrix[l])
	{
		c = 0;
		list_point = loop_find_all(matrix[l], &list_point, &i);
		l++;
	}
	list_point[i] = (t_point){-1, -1};
	return (list_point);
}

t_point	*loop_find_all(char *line_matrix, t_point **list_point, int *i)
{
	int		c;
	t_point	*list;

	c = 0;
	list = *list_point;
	while (line_matrix[l][c])
	{
		if (line_matrix[l][c] == ch)
		{
			list_point[*i] = (t_point){c, l};
			*i++;
		}
		c++;
	}
	return (list);
}

///////////////////////////////////////////

void	draw_map(t_wind *window)
{
	int		l;
	int		y;
	int		len;

	l = 0;
	y = 0;
	len = count_occurrence(window->map_matrix, '1');
	len += count_occurrence(window->map_matrix, 'C');
	window->imgs = (t_image *)ft_calloc(len, sizeof(t_image));
	if (!window->imgs)
		clean_and_exit(window);
	while (window->map_matrix[l])
	{
		draw_line(window, l, y);
		y += 50;
		l++;
	}
}

void	draw_line(t_wind *window, int line, int y)
{
	int		c;
	int		x;
	int		i;
	char	*bg;
	t_size	size;

	c = 0;
	x = 0;
	i = 0;
	size = size_map(window->map);
	while (window->map_matrix[line][c])
	{
		if (window->map_matrix[line][c] == '1')
		{
			if ((line == 0) || (line == size.height - 1) || c == 0 || (c == size.width - 1))
				bg = tatame2();
			else
				bg = tatame1();
			window->imgs[i].img_ptr = mlx_xpm_file_to_image(window->mlx, bg, &window->imgs[i].w, &window->imgs[i].h);
			mlx_put_image_to_window(window->mlx, window->win, window->imgs[i++].img_ptr, x, y);
		}
		if (window->map_matrix[line][c] == 'C')
		{
			window->imgs[i].img_ptr = mlx_xpm_file_to_image(window->mlx, star(), &window->imgs[i].w, &window->imgs[i].h);
			if (!window->imgs)
				clean_and_exit(window);
			mlx_put_image_to_window(window->mlx, window->win, window->imgs[i++].img_ptr, x+10, y+10);
		}
		x += 50;
		c++;
	}
}

void	draw_tatami(t_wind *win, int x, int y, int *i)
{
	win->imgs[*i].img_ptr = mlx_xpm_file_to_image(win->mlx, tatame1(), &win->imgs[*i].w, &win->imgs[*i].h);
	if (!win->imgs)
		clean_and_exit(win);
	mlx_put_image_to_window(win->mlx, win->win, win->imgs[*i].img_ptr, x, y);
	(*i)++;
}

int	key_press(int keycode, t_wind *win)
{
	ft_printf("Tecla: %d\n", keycode);
	(void)win;
	if (keycode == 65307)
		clean_and_exit(win);
	if (keycode == 65363)
	{
		ft_printf("--> {%i %i}\n", win->play_x, win->play_y);
		mlx_put_image_to_window(win->mlx, win->win, win->bg_img.img_ptr, win->play_x, win->play_y);
		win->play_x += 50;
	}
	if (keycode == 65361)
	{
		ft_printf("<-- {%i %i}\n", win->play_x, win->play_y);
		mlx_put_image_to_window(win->mlx, win->win, win->bg_img.img_ptr, win->play_x, win->play_y);
		win->play_x -= 50;
	}
	if (keycode == 65362)
	{
		ft_printf("^ {%i %i}\n", win->play_x, win->play_y);
		mlx_put_image_to_window(win->mlx, win->win, win->bg_img.img_ptr, win->play_x, win->play_y);
		win->play_y -= 50;
	}
	if (keycode == 65364)
	{
		ft_printf("v {%i %i}\n", win->play_x, win->play_y);
		mlx_put_image_to_window(win->mlx, win->win, win->bg_img.img_ptr, win->play_x, win->play_y);
		win->play_y += 50;
	}
	mlx_put_image_to_window(win->mlx, win->win, win->player[0][0][0].img_ptr, win->play_x, win->play_y);
	return (0);
}

void	draw_map(t_wind *win)
{
	int		l;
	int		y;
	int		i;
	int		len;

	l = 0;
	y = 0;
	i = 0;
	len = count_occurrence(win->map_matrix, '1');
	len += count_occurrence(win->map_matrix, 'C');
	win->imgs = (t_image *)ft_calloc(len, sizeof(t_image));
	if (!win->imgs)
		clean_and_exit(win);
	while (win->map_matrix[l])
	{
		draw_line_map(win, l, y, &i);
		y += 50;
		l++;
	}
}

void	draw_line_map(t_wind *win, int l, int y, int *i)
{
	int		c;
	int		x;

	c = 0;
	x = 0;
	while (win->map_matrix[l][c])
	{
		if (win->map_matrix[l][c] == '1')
		{
			if (is_border(win, l, c))
				draw_tatami_2(win, x, y, i);
			else
				draw_tatami_1(win, x, y, i);
		}
		if (win->map_matrix[l][c] == 'C')
			draw_star(win, x, y, i);
		if (win->map_matrix[l][c] == 'E')
			draw_portal(win, x, y);
		if (win->map_matrix[l][c] == 'P')
			draw_player(win, x, y);
		x += 50;
		c++;
	}
}
